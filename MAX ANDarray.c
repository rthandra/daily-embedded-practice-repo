You are given an array arr[] of N positive integers. 
The task is to find the maximum AND value generated by any pair of elements in the array using the bitwise AND operator (&).

/*
brute force way: have two loops and update max, this works but two loops is o(n^2), very bad
*/

/*void maxAnd(int *arr, int n){
    
    int MAX = 0;
    for(int i = 0; i < n; i++){
        for(int j = i+1; j < n; j++){
            if((arr[i] & arr[j]) > MAX){
                MAX = (arr[i] & arr[j]);
            }
        }
    }
    
    printf("MAX = %d\n", MAX);

}

int main(){
    
    int arr[] = {1,3,4};
    int size = sizeof(arr)/sizeof(arr[0]);
    
    maxAnd(arr, size);
    return 0;
}*/


int maxAnd(int *arr, int n){
    int count = 0;
    int ans = 0; //Stores the confirmed “best AND value” found till now.
    int bit= 0; //test.
Checks if we can safely turn on a new bit in ans
    
    for(int i = 31; i>=0; i--){ //bit pos
        bit = ans | (1<<i); //candidate is 1000....0000
        //now how do we check it with every number in array?
        
    }
    
    //checking every number in array
    for(int i = 0; i < n; i++){
        if((arr[i] & bit) == bit){
            count++;
        }
        if(count >= 2){
            break;
        }
    }
    //ans gets updated here
    if(count >= 2){
       ans = bit;
   }
   
   return ans;

}

int main(){
    
    int arr[] = {4,4};
    int size = sizeof(arr)/sizeof(arr[0]);
    
    int result = maxAnd(arr, size);
    
    printf("ans = %d\n", result);
    return 0;
}
